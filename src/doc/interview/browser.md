# 浏览器部分
## 常用的http方法都有哪些？
常用的http请求方法有get、post、put、delete等等。
get和post的区别为：
  1.get请求的请求参数是在请求地址上，相对于post的请求体里的参数来说没那么安全
  2.get请求的参数在url中是有长度限制的（这个长度限制是因为浏览器和服务器的限制，http协议本身没有对长度进行限制），post则没有
  3.get请求参数类型只支持ascll，而post则没有限制
  4.对于get请求是将header和请求参数一块发出，而大部分浏览器对post的请求为先发出header，等服务器相应100(continue)后继续发送请求体。

## 预检请求是什么？ 什么情况下会发出预检请求？
由于浏览器有同源策略的限制，在向服务器请求资源前会先发出一个预检请求，检查当前请求是否有权限获取资源。
请求分为简单请求和复杂请求
非简单请求会先发起一次option方法预检，看当前是否允许跨域
简单请求
  请求方法为head、get、post
  请求的content-type只限三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain
  请求头信息不超过：Accept、Accept-language、content-language、Last-Event-ID、content-type
复杂请求
  请求方法为put、delete
  或者请求的content-type为application/json
  
  请求头信息
    access-control-request-method：必须，列出浏览器的cors请求会用到哪些http方法
    access-control-request-headers：该字段是一个逗号分隔的字符串，

## 浏览器都有哪些状态码各对应什么意思？各状态码适用什么场景
状态码对应原因
1xx 代表请求已被接受，需要继续处理
  100 部分请求已被服务器接受，可以继续请求
  101 服务端根据客户端的请求切换协议

2xx 代表请求已成功被服务器理解并接受
  200 请求成功并返回响应头和响应体
  206 服务器成功处理了部分请求

3xx 表示请求已成功，需要进一步操作。通常用来重定向
  301(永久移动) 请求的网页已永久移动到新位置。
  302(临时移动) 服务器目前从不同位置的网页响应请求，但请求者继续使用原有位置来进行以后的请求。

4xx 代表客户端可能发生了错误，妨碍了服务器处理
  400(错误请求) 服务器不理解请求的语法
  401(未授权) 请求要请身份验证
  403(禁止) 服务器拒绝请求
  405(方法禁用) 禁用请求中指定的方法

5xx 常见于服务器发生错误
  500 服务器内部错误
  501 服务器不具备完成请求的功能
  502 错误网关
  503 服务器目前无法使用
  504 服务器超时
  505 服务器不支持请求的http协议

状态码适用场景
  100 常用于预检请求和post大数据传输
  206 常用于断点续传
  301 永久重定向缓存 新域名替换旧域名
  302 临时重定向不会缓存 常用于鉴权失效重跳登录页
  304 协商缓存
  400 参数有误 服务器无法识别
  403 禁止访问该资源或站点
  404 服务器找不到资源
  503 服务器停机维护
  504 网关超时

## http0.9,http1.0,http1.1,http2都有什么不同？对http3有了解吗？
http0.9
  http只有一个请求行，无请求头和体
  服务器无返回头信息，只返回数据
  返回的文件以ascll字节流传输
http1.0
  增加请求头和响应头
  支持文件压缩
  支持传输不同文件格式及编码格式
  提供cache机制
http1.1
  持久化连接
  提供虚拟主机机制(请求头中增加host字段)
  引入cookie机制和安全机制
  引入了更多的缓存策略
  增加了其他请求方法：put、delete、options等
http2.0
  多路复用--用以解决队头阻塞问题
  二进制分帧
  报头压缩
  服务器推送


## 常见的攻击及防御？
csrf(跨站请求伪造)
  攻击：利用服务器漏洞和用户登录状态，通过第三方站点发起请求实现攻击。
    自动发起get请求
    自动发起post请求
    引诱用户点击链接发起请求
  防御：
    利用cookie的sameSite属性
    验证请求的来源站点
      referer:记录该请求的来源地址
      origin:域名信息
    csrf token
xss(跨站脚本攻击)
  攻击:页面注入恶意脚本，可以获取cookie，伪造转账登录窗口等等。
    存储型xss:利用站点漏洞，将脚本代码注入数据库(例如网站的留言功能等等)
    反射型xss:攻击者将一段含有恶意代码的请求提交给服务器，服务器又返回给了客户端。
    基于dom的xss:攻击者将恶意脚本注入到用户页面中，通过网络劫持修改html内容。
  防御：
    服务器对注入内容进行转码
    利用csp
      限制加载其他域下的资源文件
      禁止向第三方域提交数据
      禁止执行内联脚本和未授权的脚本
    使用cookie的httpOnly

## https和http有什么不同？
http
  通信使用明文，内容可能被窃听
  不验证通信方的身份，因此有可能遭遇伪装
https：在http和tcp之间插入一个安全层(TSL/SSL)，对发送的数据进行加密，对接收的数据进行解密
  对称加密：加密解密用同一个密钥
    优点：方便、快捷
    缺点：密钥任何人都能获取到，任何人都能对数据进行加解密，安全性不高
  非对称加密：加密解密用不同的密钥
    优点：相对于对称加密有更高的安全性
    缺点：效率过低、任何人都能获取到公钥依然能够对服务器数据进行解密
  混合加密：传输数据使用对称加密，使用非对称加密加密传输数据使用的对称密钥
    优点：安全性更高、传输过程使用对称加密效率较高。
    缺点：第三方仍然可以伪造站点、伪造公钥等手段篡获取密钥篡改数据等等。
  摘要算法：发送数据时添加摘要信息(散列函数、哈希函数)
  数字证书：第三方颁发证书、该证书可以通过第三方验证保证公钥的合法性。

## 跨域都是怎么处理的？
jsonp：通过script标签没有同源策略的限制。将回调函数放到query里，服务端完成请求后会执行回调函数，将返回结果放到回调函数的参数里。
  优点：简单、兼容性好
  缺点：
    只能get请求
    安全性不够：
      csrf攻击：恶意页面请求jsonp接口。通过验证referer解决
      xss漏洞：回调函数为恶意脚本代码。严格限制content-type为application/json，并过滤脚本代码限制参数长度等解决。
cors：浏览器请求头自动添加origin字段表明来源。服务端设置Access-control-allow-origin | headers | methods。指定允许的来源、方法、头部等。
  优点：支持所有类型的http请求
  缺点：对老式浏览器的兼容不如jsonp
nginx反向代理：利用服务器和服务器见通信见没有跨域请求的特点。
  实现方式：给代理服务器设置access-control-allow-origin:*，配置代理服务器地址proxy_pass。
postMessage：常用于获取页面中的第三方数据。
  实现方式：
    发送信息方:window.parent.postMessage('message','')。
    接收信息方：mc = new MessageChannel(),mc.addEventListener('message',() => {})
document.domain：只适用于二级域名相同。
  实现方式：例如a.test.com,b.test.com。给页面添加document.domain=test.com即可

## 从浏览器角度考虑性能优化？
减小文件体积 -- 体积越大，下载越久
对非必要文件采取异步下载 -- 同步文件会阻塞主页面渲染，白屏时间过长(引出dom树构建、渲染树构建等概念)
减少文件个数 -- 同一域名下，最多可建立六个tcp连接。(引出http版本协议概念)
升级http2.0(引出http1.0,1.1,2.0相关概念)
避免频繁垃圾回收机制(引出垃圾回收机制概念)

## 从输入地址到页面展示，浏览器中间都做了什么？
检查url 组装协议 拼成完整url
浏览器将url通过进程间通信传递给网络进程
网络进程检查本地是否有缓存，如果有将资源返回给浏览器进程。
如果没有通过dns解析获取到ip地址和端口号(dns解析流程)
利用ip地址和服务器建立tcp连接(三次握手)
根据响应状态码，如果是301/302需要重定向到location所给地址，重新进行上述步骤。如果是200响应处理。
根据content-type的类型检查是否是字节流类型，是则将该请求提交到下载管理器。如果是html则通知浏览器进程准备渲染进程准备进行渲染
渲染进程检查当前url是否和之前打开的域名相同，如果相同则复用原来的渲染进程，否则准备新的渲染进程。
渲染进程准备完成，浏览器先渲染进程发起提交文档的消息，渲染进行和网络进程建立起传输数据的通道
渲染进程接受完数据后，向浏览器发送确认提交
浏览器接受到确认信息后更新界面状态，前进后退历史状态、安全、地址栏url、更新web页面等

* 浏览器输入url到页面展示的完整流程
 * 1.检查输入，组装协议，生成URL
 * 2.onbeforeunload 事件
 * 3.导航栏呈现loading状态，页面展示上一个页面
 * 4.浏览器进程构建请求行信息，将url通过ipc机制发送给网络进程
 * 5.网络进程接收到url，查找缓存cachecontrol是否过期，没有过期直接返回，结束请求
 * 5.缓存查找失败，继续发起网络请求
 * 6.准备IP地址和端口号，通过dns解析获取ip地址，端口号从url地址中获取，http默认80，https默认443
 * 7.如果是http1.1,tcp队列等待，一个域名下最多同事简历6个tcp连接，超过需要等待
 * 8.数据包在传输层添加tcp头，包括目标端口号，和本机端口号，以及数据序号，tcp需要3次握手建立连接
 * 9.网络层添加ip头，包括IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息
 * 10.物理链路层传输数据到目标服务器主机
 * 11.服务器接收到数据包，解析出来ip头，识别出数据包部分，向传输层传递
 * 12.传输层解析出tcp头部，识别出端口号，将数据包向上传输到应用层
 * 13.应用层http解析请求头和请求体，
 * 如果需要重定向，code返回301，302，同时响应头location字段添加重定向链接；
 * 如果不需要重定向，根据请求头中的ifNoneMatch（优先级高）或者lastModifiedSince字段和服务器端的数据对比判断数据是否过期，没有过期304；
 * 如果需要浏览器启用缓存，可以设置请求头中cache-control，max-age字段启用强缓存，e-tag、lastModified启用协商缓存
 * 也可以响应头setCookie设置cookie，保存登录信息
 * 14.服务器处理完数据后，数据包又通过 应用层-传输层-网络层-物理链路层-网络层-传输层-应用层（浏览器的网络进程）的顺序传输到浏览器
 * 15.数据传输完成，tcp四次挥手断开连接，如果http头部有connection:keep-alive，tcp就保持长连接
 * 16.网络进程将受到的数据包进行解析，根据详情头中的content-type字段处理不同的数据类型，
 * 如果是字节流数据，就交给下载管理器下载，导航结束；
 * 如果是text/html类型，就告知浏览器进程获取到文档，准备渲染，继续导航流程
 * 17.准备渲染进程。如果从一个页面打开了另外一个页面，两个页面属于same-site，会复用父页面的渲染进程，否则新建一个渲染进程
 * 18.浏览器接收到网络进程的响应头数据后，便向渲染进程发起‘提交文档’的请求消息
 * 19.渲染进程接收到消息后，会和网络进程建立数据传输的管道，接收数据；
 * 20.数据传输完成后，渲染进程返回‘确认提交’的请求给浏览器主进程
 * 21.浏览器进程接收到消息后，更新浏览器界面状态，包括安全状态、地址栏的url、前进后退的历史状态，并更新web页面，此时为空白页面
 * 22.在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM
 * 23.然后根据 CSS 样式表，计算出 DOM 树所有节点的样式，stylesheets
 * 24.接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。layout
 * 25.分层，处理层叠上下文，生成图层数layerTree
 * 26.为每一个图层生成绘制列表，并将其提交到合成线程
 * 27.合成线程将图层分成图块，并在光栅化线程池中将图块转化为位图
 * 28.一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。
 * 29.浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 浏览器缓存是怎么做的？有几种缓存？有什么区别？
浏览器缓存分为强缓存和协商缓存
强缓存：是指向浏览器查找该缓存结果，并根据该结果的缓存过程决定是否使用该缓存过程的结果。
强缓存的情况主要有三种
  不存在该缓存结果和缓存标识，缓存失效，直接向服务器发起请求。
  存在该缓存结果和缓存标识、但该结果已失效、强制缓存失效使用协商缓存。
  存在该缓存结果和缓存标识，且结果未失效，强制缓存生效。
控制强缓存的字段分别是Expires和cache-control，cache-control优先级比expires高
expires
  http1.0的缓存策略，该值为服务器返回该结果到期的时间，即向服务器发起请求时，如果时间小于当前值就使用缓存。
  缺点：不同客户端由于时区等差异时间不同，导致缓存失效。
cache-control
  http1.1的缓存策略，主要取值为
  public：所有内容都可缓存(客户端和代理服务器都可缓存)
  private：所有内容只有客户端可缓存，cache-control的默认值
  no-cache：客户端缓存内容，但是否使用缓存结果由协商缓存告知
  no-store：所有内容都不被缓存，即不用强缓存也不用协商缓存
  max-age=xxx：缓存内容将在xxx秒后失效
协商缓存：是指强缓存失效后，由浏览器携带缓存标识向服务器发起请求，由服务器根据标识决定是否使用缓存的过程。主要以下两种情况
  协商缓存生效返回304
  协商缓存失效返回200和请求结果
协商缓存的标识也是由响应头返回给浏览器的，控制协商缓存的字段有以下两种
  last-modified/if-modified-since
  etag/if-none-match
etag/if-none-match(服务器支持的话)的优先级高于last-modified/last-modified-since
  etag是服务器响应请求时，返回当前资源的唯一标识，if-none-match是客户端发起请求时携带的上次请求得到的etag值，根据对比是否相等决定是否使用缓存。
last-modified/if-modified-since是指资源文件在服务器最后被修改的时间
  客服端在发起请求时会携带if-modified-since字段，该字段为上次请求时的服务器返回的last-modified字段。服务器比较如果last-modified是否大于if-modified-since则更新资源，负责使用缓存。
两种缓存位置
  from memory cache:代表使用内存中的缓存。会在js和图片等文件解析后直接存于内存缓存中，所以当刷新页面时只需直接从内存缓存中读取。
    优点:快速读取
    缺点:一旦进程关闭，内存清空。占据内存资源。
  from disk cache:代表使用硬件中的缓存。会将css文件存入硬盘,每次渲染页面会从硬盘中读取缓存
    将文件写入硬盘中，每次对硬盘进行i/o操作速度慢

## 页面优化
加载阶段：
  避免过多资源加载--将js和css改为内联，或者异步加载
  减小关键资源的size--压缩内部代码，移除代码内注释内容
  提高资源请求速度--cdn加速
交互阶段：
  避免在主线程执行时间过久的脚本--可以将一次执行的函数分解为多个任务。也可以将脚本执行放到web workers中，但是web works是没有dom和bom的，所以这里只能存放一些不操作dom的脚本。
  避免强制布局
  避免布局抖动
  合理利用css合成动画
  避免频繁的垃圾回收
渲染过程：
  懒加载
  预加载
  预渲染
## 讲一下垃圾回收机制
对于原始数据，在执行上下文被销毁时，当前存放在该执行上下文中的原始数据都会被回收。
对于引用数据，引用数据是存放在堆内存中，当执行上下文销毁时，销毁掉的仅仅是对该堆内存地址的引用，而数据还是存放在堆内存中。
堆内存中的空间分为两块，新生代内存空间和老生代内存空间。
新生代内存空间中存放的是一些数据较小的对象，以及存活时间不久的对象。新生代内存空间分为对象区域和空闲区域两部分，执行垃圾回收时，将对象区域所有垃圾数据进行回收然后将剩余数据有序存放到空闲区域，然后将两个区域进行反转。
如果经历过两次新生代垃圾回收或者数据较大的数据会存放到老生代内存中。对老生代采用的是标记清除算法，先遍历所有数据，对未引用的数据打上清除标记，然后进行清除。后面会对内存空间进行整理。
由于老生代内存数据量大且在执行垃圾回收机制的时候主线程是被占用的，所以会阻塞页面造成卡顿，需要将垃圾回收分成一个一个小任务，穿插在js代码执行中进行回收。
## 为什么新生代和老生代垃圾回收机制算法不同
因为新生代数据量较小，所以每次将对象区域的所有数据转移到空闲区域开销较小。
而老生代数据量很大，转移操作效率低且分为两个内存导致内存空间使用效率大大降低。
  
